from sys import argv, path

import random
import copy
from typing import Union

from ..classes.state import State
from ..classes.station import Station
from ..classes.connection import Connection


class Algorithm():
    def __init__(self, state: 'State') -> None:
        self.state = state

    def __str__(self):
        return "Algorithm object"

    #### GENERAL METHODS ####

    def return_score(self) -> tuple[float, str]:
        """
        # TODO: doc-string
        """
        # save return variables
        score = self.state.calculate_score()
        description = self.state.show()

        return score, description

    def load_state(self, new_state: object) -> None:
        """
        # TODO: doc-string
        """
        self.state = new_state

    def read_sleeper_string(self, sleeper_string: str) -> None:
        """
        # TODO: doc-string
        """
        self.state.awaken_state(sleeper_string)

    #### METHODS FOR BONUS AND MALUS POINT CALCULATION ####

    def get_total_bonus_malus(self) -> int:
        """
        gives sum of all plus- and minuspoints generated by enabled heuristics

        returns:
            sum of all points generated by heuristics      
        """
        raise NotImplementedError

    def get_mutated_score(self) -> int:
        """
        mutates score of state with bonus/maluspoints generated by heuristics

        returns:
            mutated score of state     
        """
        return self.state.calculate_score() + self.get_total_bonus_malus()

    #### RANDOM METHODS ####

    def add_random_route(self) -> None:
        """
        adds a random 1-length route to the state

        pre: 
            self.state is a state object
            self.state.connections contains connection objects

        post:
            added a 1-length route to self.state.routes
        """
        self.state.add_route(random.choice(self.state.connections))

    def create_random_state(self, number_of_connections: int = 1) -> None:
        """
        randomly generates a state with random 1-length routes (default=1)

        pre: 
            number_of_connections is an integer

        post:
            self.state.routes contains specified number of 1-length routes
        """
        for new_connection in range(number_of_connections):
            # pick random connection and create route
            self.add_random_route()

    def add_random_connection(self, route_index: int = 0, choice: Union[str, None] = None) -> str:
        """
        # TODO: doc-string
        """

        # determine choice if not prematurely done
        if choice == None:
            choice = random.choice(['start', 'end'])

        if choice == 'start':
            new_connection = random.choice(
                self.state.routes[route_index].get_start_station().get_connections())

        elif choice == 'end':
            new_connection = random.choice(
                self.state.routes[route_index].get_end_station().get_connections())

        self.state.add_connection_to_route(
            self.state.routes[route_index], new_connection)

        return choice

    def delete_random_connection(self, route_index: int = 0, choice: Union[str, None] = None) -> str:
        """
        # TODO: doc-string
        """
        # determine choice if not prematurely done
        if choice == None:
            choice = random.choice(['start', 'end'])

        if choice == 'start':
            self.state.delete_start_connection_from_route(
                random.choice(self.state.routes))

        elif choice == 'end':
            self.state.delete_end_connection_from_route(
                random.choice(self.state.routes))

        return choice

    def delete_random_route(self) -> None:
        route = random.choice(self.state.routes)

        self.state.delete_route(route)

    #### CONNECTION SUGGESTIONS HEURISTIC ####

    def station_has_one_unused_connection(self, state: 'State', station: 'Station') -> Union[bool, 'Connection']:
        """
        checks if station only has one unused connection

        pre: 
            station is Station object

        returns:
            unused connection
            False if there is not 1 unused connection      
        """
        assert isinstance(
            type[Station], station), "station should be a Station object"

        connections = [
            connection for connection in station.connections if connection in state.unused_connections]

        if len(connections) == 1:
            return connections[0]
        return False

    def get_connection_suggestions(self, state: 'State') -> list['Connection']:
        """
        gives all connections that connect to a station that only has that connection left, so this station can become the first in a route

        returns:
            list of all connection suggestions
            Beware! Can also return an empty list!
        """
        connection_suggestions = [self.station_has_one_unused_connection(
            station) for station in state.stations if self.station_has_one_unused_connection(station)]

        return connection_suggestions
